<!DOCTYPE HTML>
<html lang="ru" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Hople C MCU guidlines</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="hople_c_mcu_guidlines.html"><strong aria-hidden="true">1.</strong> Методические рекомендации Hople по программированию на С для микроконтроллеров</a></li><li><ol class="section"><li class="chapter-item expanded "><strong aria-hidden="true">1.1.</strong> Причины появления рекомендаций</li></ol></li><li class="chapter-item expanded "><a href="C_style_guidlines.html"><strong aria-hidden="true">2.</strong> Правила оформления кода на С</a></li><li class="chapter-item expanded "><a href="lib_types.html"><strong aria-hidden="true">3.</strong> Типы библиотек</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lib_types/hardware_interfacing.html"><strong aria-hidden="true">3.1.</strong> hardware interfacing</a></li><li class="chapter-item expanded "><a href="lib_types/interfacing_independent.html"><strong aria-hidden="true">3.2.</strong> interfacing independent</a></li><li class="chapter-item expanded "><strong aria-hidden="true">3.3.</strong> Сертификация сторонних itf_in-библиотек</li><li class="chapter-item expanded "><strong aria-hidden="true">3.4.</strong> Список официальный it-библиотек</li></ol></li><li class="chapter-item expanded "><strong aria-hidden="true">4.</strong> Общая структура проектов</li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Hople C MCU guidlines</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#Методические-рекомендации-hople-по-программированию-на-С-для-микроконтроллеров" id="Методические-рекомендации-hople-по-программированию-на-С-для-микроконтроллеров">Методические рекомендации Hople по программированию на С для микроконтроллеров</a></h1>
<p>В <strong>Hople</strong> мы высокого ценим эффективность и качество во всех нашей аспектах деятельности. Программное обеспечение для микроконтроллеров не является исключением. От качества  встраиваемого ПО может зависеть жизнь и безопасность людей, некачественные алгоритмы могут приводить к выходу из строя управляемых систем и уменьшению общего срока службы, а плохая оптимизация и приводит к потреблению большого количества ресурсов, например электроэнергии. Мы считаем, что унификация способов разработки и тестирования - важный этап повышения качества и безопасности программного обеспечения для встраиваемых систем, а также эффективный способ сделать разработку дешевле и эффективнее.</p>
<p>Имея в виду данную идею мы оформили и продолжаем обновлять этот набор правил и методов разработки и тестирования программного обеспечения встраиваемых систем.</p>
<p><strong>В данной документации описаны</strong>:</p>
<ul>
<li>наши методические рекомендации по стилю кода, написанного на языке С;</li>
<li>наш взгляд на разделение кода на независимые компоненты (библиотеки) и наш подход к унификации данных компонентов;</li>
<li>наш подход к тестированию и отладке встраиваемых систем.</li>
<li>/Что-то, что я допишу потом, когда это что-то появится/</li>
</ul>
<p><strong>Данная информация распространяется в соответствии с лицензией /написать лицензию/</strong>.</p>
<p><strong>Эта документация доступна на нескольких языках</strong>:</p>
<ul>
<li><a href="https://hople-technologies.github.io/Hople-C-MCU-guidelines-EN/hople_c_mcu_guidlines.html">English</a>;</li>
<li><a href="https://hople-technologies.github.io/Hople-C-MCU-guidelines-RU/hople_c_mcu_guidlines.html">Русский</a>.</li>
</ul>
<p><strong>Мы активно приветствуем исправления и улучшения этой документации</strong>. Подробнее о внесении вклада можно почитать в файле CONTRIBUTING.md в соответствующем репозитории на gitHub:</p>
<ul>
<li>English source <a href="https://github.com/Hople-technologies/Hople-C-MCU-guidelines-EN">gitHub</a></li>
<li>Русский исходник <a href="https://github.com/Hople-technologies/Hople-C-MCU-guidelines-RU">gitHub</a></li>
</ul>
<h1><a class="header" href="#Правила-оформления-кода-на-С" id="Правила-оформления-кода-на-С">Правила оформления кода на С</a></h1>
<h1><a class="header" href="#Типы-библиотек" id="Типы-библиотек">Типы библиотек</a></h1>
<p>При разработке программного обеспечения для микроконтроллеров мы выделяем 3 типа библиотек:</p>
<ul>
<li>взаимодействия с аппаратным обеспечением (hardware interfacing);</li>
<li>зависящие от аппаратного обеспечения, но не зависящие от взаимодействия (hardware dependent, interfacing independent);</li>
<li>не зависящие от аппаратного обеспечения (hardware independent).</li>
</ul>
<p>Перед тем, как объяснить, зачем необходим каждый тип библиотек, нужно понять ситуации, возникающие при разработке программного обеспечения для микроконтроллеров:</p>
<ul>
<li>внутри современных микроконтроллеров находится большое количество периферии, соответственно каждый вывод может быть отнесен к большому количеству различных периферийных устройств;</li>
<li>настройка идентичных периферий может сильно отличаться как между различными производителями, так и между различными семействами микроконтроллеров одного производителя;</li>
<li>после добавления микроконтроллера на печатную плату, задачи всех ножек уже известны и не будут изменяться в процессе работы устройства.</li>
</ul>
<h2><a class="header" href="#Принцип-разделения-ПО-по-типам" id="Принцип-разделения-ПО-по-типам">Принцип разделения ПО по типам</a></h2>
<p>Программирование микроконтроллеров начинается с настройки и реализации взаимодействия с периферией (например считывание показаний АЦП, передачи данных по интерфейсам связи или генерации ШИМ-сигнала). Код реализующий непосредственную настройку, а также взаимодействие с периферией можно назвать &quot;<strong>программным обеспечением взаимодействия с аппаратным обеспечением</strong>&quot;, важной особенностью этого совершенно условного типа ПО является то, что оно будет отличаться как для различных семейств микроконтроллеров установленных в идентичные устройства, так и для одинаковых микроконтроллеров, установленных в различные устройства (так как требуемый от МК функционал может отличаться). </p>
<p>Далее реализуется логика обработки данных, полученных от периферии (например различные преобразования: показаний АЦП в определенный физический параметр или данных полученных от IMU в углы или скорости изменения углов). Данный тип программного обеспечения мы будем называть &quot;<strong>зависящим от аппаратного обеспечения, но не зависящими от взаимодействия</strong> с аппаратным обеспечением. Важной особенность данного типа ПО является независимость от конкретных методов взаимодействия с периферией микроконтроллера, но прим этом зависимость от конкретного типа периферии. Для объяснения этого утверждения объясним пример про обработку показаний АЦП: для вычисления значения физического параметр не важно, каким именно образом было получено значение от конкретного АЦП, с другой стороны значение имеет конкретный вид схемы измерения, разрядность АЦП и период опроса. Все важные параметры в этом примере для конкретного устройства известны заранее и не изменяются в ходе работы устройства.</p>
<p>Большое количество программного обеспечения вообще не использует какую-либо периферию цифровых устройств на которых запускается. Близкий к аппаратному обеспечению пример: алгоритмы вычисления положения объекта в пространстве по углам, полученным от различных датчиков (гироскоп, акселерометр, компас) - данные от датчиков получаются уже в физических величинах, и соответственно никакого взаимодействия с железом не происходит, такой алгоритм может использоваться как в системах управления беспилотными летательными аппаратами, так и для моделирования таких систем без каких либо изменений. Другими, идейно далекими от использования периферии являются алгоритмы кодирования и декодирования, работы с двухмерной графикой для последующего отображения на дисплеях и многое другое. Программное обеспечение данного типа мы будем называть &quot;<strong>не зависящим от аппаратного обеспечения</strong>&quot;.</p>
<p>Описанные выше типы являются условными и не имеют строгих границ, по ним можно распределить практически любые элементы ПО. Для каждого описанного типа программного обеспечения возможна реализация независимых библиотек. Мы будем называть эти библиотеки в соответствии с типами ПО, которые данные библиотеки реализуют реализуют: библиотеки <strong>независящими от аппаратного обеспечения (hardware independent libraries)</strong>, библиотеки <strong>зависящие от аппаратного обеспечения, но не зависящие от взаимодействия (hardware dependent, interfacing independent) - далее itf_in-библиотеки</strong>, библиотеки <strong>взаимодействия с аппаратным обеспечением (hardware interfacing), далее it-библиотеки</strong>.</p>
<p>Для упрощения классификации библиотек введем три правила:</p>
<ul>
<li>если в библиотеке есть хотя бы одна функция, реализующая настройку или взаимодействие с каким-либо видом микроконтроллеров, данная библиотека называться itf вне зависимости от объема и остального содержания;</li>
<li>если в библиотеке есть хотя бы одна функция, реализующая обработку данных от конкретной периферии, но нет функций настройки и взаимодействия с периферией, данная библиотека относится к типу itf_in;</li>
<li>если в библиотеке нет никаких зависимостей от периферии (будь то настройка, взаимодействие или обработка), библиотека будет независящей от аппаратного обеспечения.</li>
</ul>
<h2><a class="header" href="#Наш-подход-к-работе-с-каждым-типом-библиотек" id="Наш-подход-к-работе-с-каждым-типом-библиотек">Наш подход к работе с каждым типом библиотек</a></h2>
<p><strong>Мы не беремся каким-либо образом классифицировать и стандартизировать независящие от аппаратного обеспечения библиотеки</strong>, так как они очень распространены и могут быть применены далеко за пределами разработки программного обеспечения для встраиваемых систем.</p>
<p><strong>Нашей основной целью является продвижение идеи itf_in-библиотек и стандартизация их оформления</strong> для обеспечения более унифицированного интерфейса взаимодействия между различными устройствами и микроконтроллерами любых производителей. Для понимания идеи itf_in-библиотек рассмотри простой пример стандартного подхода к разработке и использованию библиотеки такого рода.</p>
<p><strong>Каждая interfacing independent библиотека должна формулировать требования к устройству на котором будет запущена</strong>. Данные требования должны исполняться в коде инициализации устройства, например, посредством написания itf-библиотеки, или использования предоставляемых многими современными производителями микроконтроллеров библиотек надстройки надстройки над аппаратным обеспечением (HAL). Требования в общем случае можно разделить на два вида: требования по настройке периферии, и требования по реализации интерфейса взаимодействия с периферией.
Например, разрабатывается itf_in библиотека по обмену данными с 3-осевым гироскопом. Обмен данными с гироскопом происходит посредством интерфейса SPI, а также 1 цифровой ножки для включения устройства из режима сна.<br />
Во-первых, <strong>itf_in-библиотека может быть запущена только на микроконтроллере, имеющим необходимую периферию</strong>, для нашего примера микроконтроллер должен либо иметь свободный аппаратный SPI-интерфейс, либо реализовывать программный.
Во-вторых, <strong>itf_in-библиотека должна выдвигать требования к настройкам и интерфейсу взаимодействия с периферией микроконтроллера</strong>. Для нашего примера** требования к настройкам периферии** могут представлять требования к настройке интерфейса SPI (скорости обмена данными, вида кадра, и так далее) и требования к настройке ножки микроконтроллера в режим цифрового выхода. Требования к интерфейсу взаимодействия с периферией могут включать: наличие трех функций:</p>
<ul>
<li>с одним входным параметром типа int8_t, возвращающая значение типа int8_t. Функция должна отправлять по интерфейсу SPI входной байт и возвращать полученный байт;</li>
<li>без входных и выходных параметров. Устанавливающая на подключенной к гироскопу ножке микроконтроллера &quot;1&quot;. Необходимость представлять даже такую элементарную операцию, как установка установка ножки в &quot;1&quot;, в виде отдельной функции, а не макроса, обоснована и подробно описана в главе про itf_in библиотеки;</li>
<li>без входных и выходных параметров. Устанавливающая на подключенной к гироскопу ножке микроконтроллера &quot;0&quot;;
<strong>На основании выставленный требований, itf_in-библиотека реализует задуманный функционал</strong>. В нашем примере библиотека может использовать указатели на функции изменения состояния цифровой ножки для включения и выключения микросхемы, а также указатель на функцию отправки данных и получения даннах от интерфейса SPI, благодаря чему становится возможным организация любого, сколь угодно сложного обмена данными с целевой микросхемой. Таким образом используя относительно простой предоставленный интерфейс связи itf_in-библиотека может реализовать сложные алгоритмы взаимодействия с периферией и при этом будет являться кроссплатформенной, так как не обращается напрямую к периферии какого-то конкретного микроконтроллера, а работает с предоставленным интерфейсом, то есть может быть запущена на любом микроконтроллере, который может предоставить необходимый интерфейс. В целя уточнения надо заметить, что itf_in библиотеке в примере совершенно не важно с каким именно SPI на микроконтроллера она будет работать и какой ножкой будет управлять, она просто использует указатели на функции и соответственно будет работать с тем интерфейсом и ножкой, взаимодействие с которыми реализуется в функции.</li>
</ul>
<h2><a class="header" href="#Преимущества-использования-itf_in-библиотек" id="Преимущества-использования-itf_in-библиотек">Преимущества использования itf_in-библиотек</a></h2>
<p>Главная идея itf_in-библиотек повсеместная унификация программного обеспечения для встраиваемых систем, которая может быть полезна всем основным сторонам разработки: производителям микроконтроллеров, производителем микросхем, разработчикам программного обеспечения.</p>
<h3><a class="header" href="#Преимущества-для-производителей-микроконтроллеров" id="Преимущества-для-производителей-микроконтроллеров">Преимущества для производителей микроконтроллеров</a></h3>
<p>Большинство крупных производителей микроконтроллеров уже сейчас в том или ином виде имеют библиотеки надстройки над аппаратным обеспечением, которые могут быть применены в качестве itf-библиотек и соответственно делают процесс организации интерфейса взаимодействия с itf_in библиотеками тривиальным. Соответственно для многих производителей микроконтроллеров выгода будет в том, что они уже предоставляют готовое решение упрощающее жизнь разработчикам программного обеспечения. Кроме того, стандартизация itf_in-библиотек позволит сформировать базу методов, которые должны присутствовать для любых семейств микроконтроллеров, что позволит при необходимости расширить уже имеющиеся HAL-библиотеки и облегчит проектирование библиотек для производителей, которые таковых еще не имеют.</p>
<h3><a class="header" href="#Для-производителей-микросхем" id="Для-производителей-микросхем">Для производителей микросхем</a></h3>
<p>При производстве микросхем подразумевается фиксированный набор способов, посредством которых можно управлять конкретной микросхемой, что дает возможность разрабатывать полноценные itf_in библиотеки практически для любого типа микросхем, от памяти, до драйверов двигателей переменного тока. При этом наличие стандартизированных itf_in-библиотек у производителя может значительно упростить процесс разработки итогового программного обеспечения, и соответственно сделает конкретную микросхему более привлекательной для потребителей.</p>
<h3><a class="header" href="#Для-разработчиков-программного-обеспечения" id="Для-разработчиков-программного-обеспечения">Для разработчиков программного обеспечения</a></h3>
<p>itf-библиотеки значительно упрощают разработчиком, так как избавляют их от оков конкретной архитектуры микроконтроллеров, так как раньше для каждой архитектуры приходилось разрабатывать собственные библиотеки. Кроме этого при желании разработчики могут игнорировать готовые HAL-библиотеки и разрабатывать свои, более подходящие по внутренним правилам интерфейсы, что также не отнимает гибкость разработки.</p>
<p>Общая схема взаимодействия модулей показаны на рисунке ниже:</p>
<p align="center">
  <img width="360" src="https://github.com/Hople-technologies/Hople-C-MCU-guidelines-RU/src/images/itf_in-implementation-sheme.png">
</p>
<p><strong>Правила формирования itf_in библиотек</strong> описаны в главе <a href="https://hople-technologies.github.io/Hople-C-MCU-guidelines-RU/lib_types/interfacing_independent.html">interfacing independent</a>.<br />
Кроме этого мы сказали про itf-библиотеки, но не привели пример того, что под этим подразумеваем. <strong>itf-библиотеки</strong> - наш внутренний способ разработки HAL-библиотек для каждой конкретной печатной платы. Такой подход дает максимальный контроль и позволяет в удобном виде настраивать устройство и использовать любые подходящие itf-библиотеки.** В отличии от itf_in-библиотек мы не продвигаем повсеместное использование itf-библиотек**, но наш формат оформления описан в главе <a href="https://hople-technologies.github.io/Hople-C-MCU-guidelines-RU/lib_types/hardware_interfacing.html">hardware interfacing</a>.</p>
<p>(В это описание надо со временем привести побольше примеров с кодом и пару картинок, разъясняющих ситуацию)
Сейчас еще задумался о том, что impi-библиотеки это именно библиотеки взаимодействия с какого-то рода конкретными устройствами (микросхемами или каскадами) и возможно есть смысл ввести еще четвертый тип библиотек, схожих по наполнению с impi, но необходимых для реализации логики работы какого-то конкретного устройства - что-то, что я когда-то называл device-библиотеками, но это надо смотреть на практике</p>
<p><strong>Важно еще написать что вообще подразумевается под библиотекой (мол это не один .h-файл, а их набор, главный из которых имеет в названии нужный постфикс)</strong></p>
<h1><a class="header" href="#interfacing-independent" id="interfacing-independent">interfacing independent</a></h1>
<h1><a class="header" href="#interfacing-independent-1" id="interfacing-independent-1">interfacing independent</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
