# Типы библиотек

При разработке программного обеспечения для микроконтроллеров мы выделяем 3 типа библиотек:
* взаимодействия с аппаратным обеспечением (hardware interfacing);
* зависящие от аппаратного обеспечения, но не зависящие от взаимодействия (hardware dependent, interfacing independent);
* не зависящие от аппаратного обеспечения (hardware independent).

Перед тем, как объяснить, зачем необходим каждый тип библиотек, нужно понять ситуации, возникающие при разработке программного обеспечения для микроконтроллеров:
* внутри современных микроконтроллеров находится большое количество периферии, соответственно каждый вывод может быть отнесен к большому количеству различных периферийных устройств;
* настройка идентичных периферий может сильно отличаться как между различными производителями, так и между различными семействами микроконтроллеров одного производителя;
* после добавления микроконтроллера на печатную плату, задачи всех ножек уже известны и не будут изменяться в процессе работы устройства.

## Принцип разделения ПО по типам

Программирование микроконтроллеров начинается с настройки и реализации взаимодействия с периферией (например считывание показаний АЦП, передачи данных по интерфейсам связи или генерации ШИМ-сигнала). Код реализующий непосредственную настройку, а также взаимодействие с периферией можно назвать "**программным обеспечением взаимодействия с аппаратным обеспечением**", важной особенностью этого совершенно условного типа ПО является то, что оно будет отличаться как для различных семейств микроконтроллеров установленных в идентичные устройства, так и для одинаковых микроконтроллеров, установленных в различные устройства (так как требуемый от МК функционал может отличаться). 

Далее реализуется логика обработки данных, полученных от периферии (например различные преобразования: показаний АЦП в определенный физический параметр или данных полученных от IMU в углы или скорости изменения углов). Данный тип программного обеспечения мы будем называть "**зависящим от аппаратного обеспечения, но не зависящими от взаимодействия** с аппаратным обеспечением. Важной особенность данного типа ПО является независимость от конкретных методов взаимодействия с периферией микроконтроллера, но прим этом зависимость от конкретного типа периферии. Для объяснения этого утверждения объясним пример про обработку показаний АЦП: для вычисления значения физического параметр не важно, каким именно образом было получено значение от конкретного АЦП, с другой стороны значение имеет конкретный вид схемы измерения, разрядность АЦП и период опроса. Все важные параметры в этом примере для конкретного устройства известны заранее и не изменяются в ходе работы устройства.

Большое количество программного обеспечения вообще не использует какую-либо периферию цифровых устройств на которых запускается. Близкий к аппаратному обеспечению пример: алгоритмы вычисления положения объекта в пространстве по углам, полученным от различных датчиков (гироскоп, акселерометр, компас) - данные от датчиков получаются уже в физических величинах, и соответственно никакого взаимодействия с железом не происходит, такой алгоритм может использоваться как в системах управления беспилотными летательными аппаратами, так и для моделирования таких систем без каких либо изменений. Другими, идейно далекими от использования периферии являются алгоритмы кодирования и декодирования, работы с двухмерной графикой для последующего отображения на дисплеях и многое другое. Программное обеспечение данного типа мы будем называть "**не зависящим от аппаратного обеспечения**".

Описанные выше типы являются условными и не имеют строгих границ, по ним можно распределить практически любые элементы ПО. Для каждого описанного типа программного обеспечения возможна реализация независимых библиотек. Мы будем называть эти библиотеки в соответствии с типами ПО, которые данные библиотеки реализуют реализуют: библиотеки **независящими от аппаратного обеспечения (hardware independent libraries)**, библиотеки **зависящие от аппаратного обеспечения, но не зависящие от взаимодействия (hardware dependent, interfacing independent) - далее itf_in-библиотеки**, библиотеки **взаимодействия с аппаратным обеспечением (hardware interfacing), далее it-библиотеки**.

Для упрощения классификации библиотек введем три правила:
* если в библиотеке есть хотя бы одна функция, реализующая настройку или взаимодействие с каким-либо видом микроконтроллеров, данная библиотека называться itf вне зависимости от объема и остального содержания;
* если в библиотеке есть хотя бы одна функция, реализующая обработку данных от конкретной периферии, но нет функций настройки и взаимодействия с периферией, данная библиотека относится к типу itf_in;
* если в библиотеке нет никаких зависимостей от периферии (будь то настройка, взаимодействие или обработка), библиотека будет независящей от аппаратного обеспечения.

## Наш подход к работе с каждым типом библиотек

**Мы не беремся каким-либо образом классифицировать и стандартизировать независящие от аппаратного обеспечения библиотеки**, так как они очень распространены и могут быть применены далеко за пределами разработки программного обеспечения для встраиваемых систем.

**Нашей основной целью является продвижение идеи itf_in-библиотек и стандартизация их оформления** для обеспечения более унифицированного интерфейса взаимодействия между различными устройствами и микроконтроллерами любых производителей. Для понимания идеи itf_in-библиотек рассмотри простой пример стандартного подхода к разработке и использованию библиотеки такого рода.

**Каждая interfacing independent библиотека должна формулировать требования к устройству на котором будет запущена**. Данные требования должны исполняться в коде инициализации устройства, например, посредством написания itf-библиотеки, или использования предоставляемых многими современными производителями микроконтроллеров библиотек надстройки надстройки над аппаратным обеспечением (HAL). Требования в общем случае можно разделить на два вида: требования по настройке периферии, и требования по реализации интерфейса взаимодействия с периферией.
Например, разрабатывается itf_in библиотека по обмену данными с 3-осевым гироскопом. Обмен данными с гироскопом происходит посредством интерфейса SPI, а также 1 цифровой ножки для включения устройства из режима сна.  
Во-первых, **itf_in-библиотека может быть запущена только на микроконтроллере, имеющим необходимую периферию**, для нашего примера микроконтроллер должен либо иметь свободный аппаратный SPI-интерфейс, либо реализовывать программный.
Во-вторых, **itf_in-библиотека должна выдвигать требования к настройкам и интерфейсу взаимодействия с периферией микроконтроллера**. Для нашего примера** требования к настройкам периферии** могут представлять требования к настройке интерфейса SPI (скорости обмена данными, вида кадра, и так далее) и требования к настройке ножки микроконтроллера в режим цифрового выхода. Требования к интерфейсу взаимодействия с периферией могут включать: наличие трех функций:
* с одним входным параметром типа int8_t, возвращающая значение типа int8_t. Функция должна отправлять по интерфейсу SPI входной байт и возвращать полученный байт;
* без входных и выходных параметров. Устанавливающая на подключенной к гироскопу ножке микроконтроллера "1". Необходимость представлять даже такую элементарную операцию, как установка установка ножки в "1", в виде отдельной функции, а не макроса, обоснована и подробно описана в главе про itf_in библиотеки;
* без входных и выходных параметров. Устанавливающая на подключенной к гироскопу ножке микроконтроллера "0";
**На основании выставленный требований, itf_in-библиотека реализует задуманный функционал**. В нашем примере библиотека может использовать указатели на функции изменения состояния цифровой ножки для включения и выключения микросхемы, а также указатель на функцию отправки данных и получения даннах от интерфейса SPI, благодаря чему становится возможным организация любого, сколь угодно сложного обмена данными с целевой микросхемой. Таким образом используя относительно простой предоставленный интерфейс связи itf_in-библиотека может реализовать сложные алгоритмы взаимодействия с периферией и при этом будет являться кроссплатформенной, так как не обращается напрямую к периферии какого-то конкретного микроконтроллера, а работает с предоставленным интерфейсом, то есть может быть запущена на любом микроконтроллере, который может предоставить необходимый интерфейс. В целя уточнения надо заметить, что itf_in библиотеке в примере совершенно не важно с каким именно SPI на микроконтроллера она будет работать и какой ножкой будет управлять, она просто использует указатели на функции и соответственно будет работать с тем интерфейсом и ножкой, взаимодействие с которыми реализуется в функции.

## Преимущества использования itf_in-библиотек

Главная идея itf_in-библиотек повсеместная унификация программного обеспечения для встраиваемых систем, которая может быть полезна всем основным сторонам разработки: производителям микроконтроллеров, производителем микросхем, разработчикам программного обеспечения.

### Преимущества для производителей микроконтроллеров
Большинство крупных производителей микроконтроллеров уже сейчас в том или ином виде имеют библиотеки надстройки над аппаратным обеспечением, которые могут быть применены в качестве itf-библиотек и соответственно делают процесс организации интерфейса взаимодействия с itf_in библиотеками тривиальным. Соответственно для многих производителей микроконтроллеров выгода будет в том, что они уже предоставляют готовое решение упрощающее жизнь разработчикам программного обеспечения. Кроме того, стандартизация itf_in-библиотек позволит сформировать базу методов, которые должны присутствовать для любых семейств микроконтроллеров, что позволит при необходимости расширить уже имеющиеся HAL-библиотеки и облегчит проектирование библиотек для производителей, которые таковых еще не имеют.

### Для производителей микросхем
При производстве микросхем подразумевается фиксированный набор способов, посредством которых можно управлять конкретной микросхемой, что дает возможность разрабатывать полноценные itf_in библиотеки практически для любого типа микросхем, от памяти, до драйверов двигателей переменного тока. При этом наличие стандартизированных itf_in-библиотек у производителя может значительно упростить процесс разработки итогового программного обеспечения, и соответственно сделает конкретную микросхему более привлекательной для потребителей.

### Для разработчиков программного обеспечения
itf-библиотеки значительно упрощают разработчиком, так как избавляют их от оков конкретной архитектуры микроконтроллеров, так как раньше для каждой архитектуры приходилось разрабатывать собственные библиотеки. Кроме этого при желании разработчики могут игнорировать готовые HAL-библиотеки и разрабатывать свои, более подходящие по внутренним правилам интерфейсы, что также не отнимает гибкость разработки.

Общая схема взаимодействия модулей показаны на рисунке ниже:

<p align="center">
  <img width="360" src="https://github.com/Hople-technologies/Hople-C-MCU-guidelines-RU/blob/master/images/itf_in-implementation-sheme.png">
</p>

**Правила формирования itf_in библиотек** описаны в главе [interfacing independent][interfacing independent].  
Кроме этого мы сказали про itf-библиотеки, но не привели пример того, что под этим подразумеваем. **itf-библиотеки** - наш внутренний способ разработки HAL-библиотек для каждой конкретной печатной платы. Такой подход дает максимальный контроль и позволяет в удобном виде настраивать устройство и использовать любые подходящие itf-библиотеки.** В отличии от itf_in-библиотек мы не продвигаем повсеместное использование itf-библиотек**, но наш формат оформления описан в главе [hardware interfacing][hardware interfacing].



(В это описание надо со временем привести побольше примеров с кодом и пару картинок, разъясняющих ситуацию)
Сейчас еще задумался о том, что impi-библиотеки это именно библиотеки взаимодействия с какого-то рода конкретными устройствами (микросхемами или каскадами) и возможно есть смысл ввести еще четвертый тип библиотек, схожих по наполнению с impi, но необходимых для реализации логики работы какого-то конкретного устройства - что-то, что я когда-то называл device-библиотеками, но это надо смотреть на практике

**Важно еще написать что вообще подразумевается под библиотекой (мол это не один .h-файл, а их набор, главный из которых имеет в названии нужный постфикс)**


[interfacing independent]:https://hople-technologies.github.io/Hople-C-MCU-guidelines-RU/lib_types/interfacing_independent.html
[hardware interfacing]:https://hople-technologies.github.io/Hople-C-MCU-guidelines-RU/lib_types/hardware_interfacing.html