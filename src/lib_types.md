# Типы библиотек

При разработке программного обеспечения для микроконтроллеров мы выделяем 3 типа библиотек:
* взаимодействия с аппаратным обеспечением (hardware interfacing);
* зависящие от аппаратного обеспечения, но не зависящие от взаимодействия (hardware dependent, interfacing independent);
* не зависящие от аппаратного обеспечения (hardware independent).

Перед тем, как объяснить, зачем необходим каждый тип библиотек, нужно понять ситуации, возникающие при разработке программного обеспечения для микроконтроллеров:
* внутри современных микроконтроллеров находится большое количество периферии, соответственно каждый вывод может быть отнесен к большому количеству различных периферийных устройств;
* настройка идентичных периферий может сильно отличаться как между различными производителями, так и между различными семействами микроконтроллеров одного производителя;
* после добавления микроконтроллера на печатную плату, задачи всех ножек уже известны и не будут изменяться в процессе работы устройства.

## Принцип разделения ПО по типам

Программирование микроконтроллеров начинается с настройки и реализации взаимодействия с периферией (например считывание показаний АЦП, передачи данных по интерфейсам связи или генерации ШИМ-сигнала). Код реализующий непосредственную настройку, а также взаимодействие с периферией можно назвать "**программным обеспечением взаимодействия с аппаратным обеспечением**", важной особенностью этого совершенно условного типа ПО является то, что оно будет отличаться как для различных семейств микроконтроллеров установленных в идентичные устройства, так и для одинаковых микроконтроллеров, установленных в различные устройства (так как требуемый от МК функционал может отличаться). 

Далее реализуется логика обработки данных, полученных от периферии (например различные преобразования: показаний АЦП в определенный физический параметр или данных полученных от IMU в углы или скорости изменения углов). Данный тип программного обеспечения мы будем называть "**зависящим от аппаратного обеспечения, но не зависящими от взаимодействия** с аппаратным обеспечением. Важной особенность данного типа ПО является независимость от конкретных методов взаимодействия с периферией микроконтроллера, но прим этом зависимость от конкретного типа периферии. Для объяснения этого утверждения объясним пример про обработку показаний АЦП: для вычисления значения физического параметр не важно, каким именно образом было получено значение от конкретного АЦП, с другой стороны значение имеет конкретный вид схемы измерения, разрядность АЦП и период опроса. Все важные параметры в этом примере для конкретного устройства известны заранее и не изменяются в ходе работы устройства.

Большое количество программного обеспечения вообще не использует какую-либо периферию цифровых устройств на которых запускается. Близкий к аппаратному обеспечению пример: алгоритмы вычисления положения объекта в пространстве по углам, полученным от различных датчиков (гироскоп, акселерометр, компас) - данные от датчиков получаются уже в физических величинах, и соответственно никакого взаимодействия с железом не происходит, такой алгоритм может использоваться как в системах управления беспилотными летательными аппаратами, так и для моделирования таких систем без каких либо изменений. Другими, идейно далекими от использования периферии являются алгоритмы кодирования и декодирования, работы с двухмерной графикой для последующего отображения на дисплеях и многое другое. Программное обеспечение данного типа мы будем называть "**не зависящим от аппаратного обеспечения**".

Описанные выше типы являются условными и не имеют строгих границ, по ним можно распределить практически любые элементы ПО. Для каждого описанного типа программного обеспечения возможна реализация независимых библиотек. Мы будем называть эти библиотеки в соответствии с типами ПО, которые данные библиотеки реализуют реализуют: библиотеки **независящими от аппаратного обеспечения (hardware independent libraries)**, библиотеки **зависящие от аппаратного обеспечения, но не зависящие от взаимодействия (hardware dependent, interfacing independent) - далее itf_in-библиотеки**, библиотеки **взаимодействия с аппаратным обеспечением (hardware interfacing), далее it-библиотеки**.

Для упрощения классификации библиотек введем три правила:
* если в библиотеке есть хотя бы одна функция, реализующая настройку или взаимодействие с каким-либо видом микроконтроллеров, данная библиотека называться itf вне зависимости от объема и остального содержания;
* если в библиотеке есть хотя бы одна функция, реализующая обработку данных от конкретной периферии, но нет функций настройки и взаимодействия с периферией, данная библиотека относится к типу itf_in;
* если в библиотеке нет никаких зависимостей от периферии (будь то настройка, взаимодействие или обработка), библиотека будет независящей от аппаратного обеспечения.

## Наш подход к работе с каждым типом библиотек

**Мы не беремся каким-либо образом классифицировать и стандартизировать независящие от аппаратного обеспечения библиотеки**, так как они очень распространены и могут быть применены далеко за пределами разработки программного обеспечения для встраиваемых систем.

**Нашей основной целью является продвижение идеи itf_in-библиотек и стандартизация их оформления** для обеспечения более унифицированного интерфейса взаимодействия между различными целевыми микросхемами (ИС различных видов, которые управляются микроконтроллерами) и микроконтроллерами любых производителей. Для понимания идеи itf_in-библиотек рассмотри простой пример стандартного подхода к разработке и использованию библиотеки такого рода.

**Каждая interfacing independent библиотека должна формулировать требования к устройству на котором будет запущена**. Данные требования должны исполняться в коде инициализации устройства, например, посредством написания itf-библиотеки (о которых будет написано после примера), или с использованием предоставляемых многими современными производителями микроконтроллеров библиотек надстройки надстройки над аппаратным обеспечением (HAL). Требования в общем случае можно разделить на два вида: требования по настройке периферии, и требования по реализации интерфейса взаимодействия с периферией.
Например, разрабатывается itf_in-библиотека по обмену данными с 3-осевым гироскопом - целевой микросхемой. Обмен данными с гироскопом происходит посредством интерфейса SPI, а также 1 цифровой ножки для включения устройства из режима сна.  
Во-первых, **itf_in-библиотека может быть запущена только на микроконтроллере, имеющим необходимую периферию**, для нашего примера микроконтроллер должен либо иметь свободный аппаратный SPI-интерфейс, либо реализовывать программный.
Во-вторых, **itf_in-библиотека должна выдвигать требования к настройкам и интерфейсу взаимодействия с периферией микроконтроллера**. Для нашего примера **требования к настройкам периферии** могут представлять требования к настройке интерфейса SPI (скорости обмена данными, вида кадра, и так далее) и требования к настройке ножки микроконтроллера в режим цифрового выхода.  
**Требования к интерфейсу взаимодействия с периферией** могут включать: наличие трех функций:
* с одним входным параметром типа int8_t, возвращающая значение типа int8_t. Функция должна отправлять по интерфейсу SPI входной байт и возвращать полученный из интерфеса байт;
* без входных и выходных параметров. Устанавливающая на подключенной к гироскопу ножке микроконтроллера "1". Необходимость представлять даже такую элементарную операцию, как установка установка ножки в "1", в виде отдельной функции, а не макроса, обоснована и подробно описана в главе про itf_in-библиотеки;
* без входных и выходных параметров. Устанавливающая на подключенной к гироскопу ножке микроконтроллера "0";
**На основании выставленный требований, itf_in-библиотека реализует задуманный функционал**. В нашем примере библиотека может использовать указатели на функции изменения состояния цифровой ножки для включения и выключения микросхемы, а также указатель на функцию отправки данных и получения даннах от интерфейса SPI, благодаря чему становится возможным организация любого, сколь угодно сложного обмена данными с целевой микросхемой (гироскопом). Таким образом используя относительно простой предоставленный интерфейс связи itf_in-библиотека может реализовать сложные алгоритмы взаимодействия с периферией и при этом будет являться кроссплатформенной, так как не обращается напрямую к периферии какого-то конкретного микроконтроллера, а работает с предоставленным интерфейсом, то есть может быть запущена на любом микроконтроллере, который может предоставить необходимый интерфейс. В целях уточнения надо заметить, что itf_in-библиотеке в примере совершенно не важно с каким именно SPI на микроконтроллера она будет работать и какой ножкой будет управлять, она просто использует указатели на функции и соответственно будет работать с тем интерфейсом и ножкой, взаимодействие с которыми реализуется в функции.

## Преимущества использования itf_in-библиотек

Главная идея itf_in-библиотек повсеместная унификация программного обеспечения для встраиваемых систем, которая может быть полезна всем основным сторонам разработки: производителям микроконтроллеров, производителем целевых микросхем, разработчикам программного обеспечения.

### Преимущества для производителей микроконтроллеров
Большинство крупных производителей микроконтроллеров уже сейчас в том или ином виде имеют библиотеки надстройки над аппаратным обеспечением, которые могут быть применены в качестве itf-библиотек и соответственно делают процесс организации интерфейса взаимодействия с itf_in-библиотеками тривиальным. Соответственно большинство производителей микроконтроллеров уже поддерживают концепцию itf_in-библиотек. Кроме этого, стандартизация itf_in-библиотек позволит сформировать базу методов, которые должны присутствовать для любых семейств микроконтроллеров, что позволит при необходимости расширить уже имеющиеся HAL-библиотеки и облегчит проектирование библиотек для производителей, которые таковых еще не имеют.

### Для производителей микросхем
Производители целевых микросхем (например драйверов двигателей, различных датчиков, микросхем памяти или вообще любых управляемых ИС, которые не являются микроконтроллерами) продумывают то, как именно микроконтроллеры будут обмениваться данными с их устройствами и соответственно могут разрабатывать itf_in-библиотеки для своих ИС. Данные библиотеки могут реализовывать настройку и управления целевыми микросхемами, и, учитывая формат itf_in библиотек, будут полностью кроссплатформенными, что позволит отлаживать их один раз на любом микроконтроллере и быть уверенным, что они будут работать на любом другом, имеющим требуемую периферию. Наличие itf_in-библиотеки значительно упростит разработку программного обеспечения на целевых устройствах и сделает микросхему более привлекательной для разработчиков и соответственно покупателей.


### Для разработчиков программного обеспечения
itf-библиотеки значительно упрощают процесс разработки, так как избавляют программистов от необходимости разрабатывать с нуля или переделывать имеющуюся библиотеку из-за отсутствия поддержки конкретного микроконтроллера. Кроме этого при желании разработчики могут игнорировать готовые HAL-библиотеки и разрабатывать свои, более подходящие под "внутренние правила" интерфейсы, что может обеспечить высокую гибкость итогового ПО.

Общая схема взаимодействия модулей показаны на рисунке ниже:
<!-- 
<p align="center">
  <img width="640" src="https://hople-technologies.github.io/Hople-C-MCU-guidelines-RU/images/itf_in-implementation-sheme.png">
</p> -->


![some](images/itf_in-implementation-sheme.png)

**Правила формирования itf_in-библиотек** описаны в главе [interfacing independent][interfacing independent].  
Кроме этого мы сказали про itf-библиотеки, но не привели пример того, что под этим подразумеваем. **itf-библиотеки** - наш внутренний способ разработки HAL-библиотек для каждой конкретной печатной платы. Такой подход дает максимальный контроль и позволяет в удобном виде настраивать устройство и использовать любые подходящие itf-библиотеки.** В отличии от itf_in-библиотек мы не продвигаем повсеместное использование itf-библиотек**, но наш формат оформления описан в главе [hardware interfacing][hardware interfacing].



(В это описание надо со временем привести побольше примеров с кодом и пару картинок, разъясняющих ситуацию)
Сейчас еще задумался о том, что itf_in-библиотеки это именно библиотеки взаимодействия с какого-то рода конкретными устройствами (микросхемами или каскадами) и возможно есть смысл ввести еще четвертый тип библиотек, схожих по наполнению с itf_in, но необходимых для реализации логики работы какого-то конкретного устройства - что-то, что я когда-то называл device-библиотеками, но это надо смотреть на практике

**Важно еще написать что вообще подразумевается под библиотекой (мол это не один .h-файл, а их набор, главный из которых имеет в названии нужный постфикс)**


[interfacing independent]:https://hople-technologies.github.io/Hople-C-MCU-guidelines-RU/lib_types/interfacing_independent.html
[hardware interfacing]:https://hople-technologies.github.io/Hople-C-MCU-guidelines-RU/lib_types/hardware_interfacing.html